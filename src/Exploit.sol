// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Euler Finance — donateToReserves Exploit Simulation
/// @notice Educational reproduction of the missing health check in donateToReserves()
///         that allowed self-liquidation via flash loan.

/// @dev Minimal ERC20 for testing
contract MockToken {
    string public name;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name) { name = _name; }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

/// @dev Simplified Euler-like lending protocol
contract SimplifiedEuler {
    MockToken public underlying;

    // eToken balances (collateral receipt)
    mapping(address => uint256) public eTokenBalance;
    // dToken balances (debt)
    mapping(address => uint256) public dTokenBalance;
    // Reserve
    uint256 public reserveBalance;

    // 1:1 exchange rate for simplicity
    uint256 public constant COLLATERAL_FACTOR = 9000; // 90% LTV
    uint256 public constant LIQUIDATION_BONUS = 500;  // 5% bonus
    uint256 public constant BASIS_POINTS = 10000;

    event Deposit(address indexed user, uint256 amount);
    event Mint(address indexed user, uint256 amount);
    event DonateToReserves(address indexed user, uint256 amount);
    event Liquidation(address indexed liquidator, address indexed violator, uint256 repay, uint256 yield_);

    constructor(address _underlying) {
        underlying = MockToken(_underlying);
    }

    /// @notice Deposit underlying → receive eTokens (collateral)
    function deposit(uint256 amount) external {
        underlying.transferFrom(msg.sender, address(this), amount);
        eTokenBalance[msg.sender] += amount;
        emit Deposit(msg.sender, amount);
    }

    /// @notice Borrow underlying (mint dTokens)
    function mint(uint256 amount) external {
        dTokenBalance[msg.sender] += amount;
        underlying.transfer(msg.sender, amount);
        // Health check after borrowing
        require(isHealthy(msg.sender), "unhealthy after mint");
        emit Mint(msg.sender, amount);
    }

    /// @notice VULNERABLE — Donate eTokens to reserve WITHOUT health check
    function donateToReservesBuggy(uint256 amount) external {
        require(eTokenBalance[msg.sender] >= amount, "insufficient balance");
        eTokenBalance[msg.sender] -= amount;
        reserveBalance += amount;
        // ❌ NO checkLiquidity(msg.sender) — this is the bug!
        emit DonateToReserves(msg.sender, amount);
    }

    /// @notice FIXED — Donate with health check
    function donateToReservesFixed(uint256 amount) external {
        require(eTokenBalance[msg.sender] >= amount, "insufficient balance");
        eTokenBalance[msg.sender] -= amount;
        reserveBalance += amount;
        // ✅ Health check after state change
        require(isHealthy(msg.sender), "unhealthy after donate");
        emit DonateToReserves(msg.sender, amount);
    }

    /// @notice Liquidate an unhealthy position
    function liquidate(address violator, uint256 repayAmount) external {
        require(!isHealthy(violator), "position is healthy");
        require(repayAmount <= dTokenBalance[violator], "repay exceeds debt");

        // Liquidator repays debt
        underlying.transferFrom(msg.sender, address(this), repayAmount);
        dTokenBalance[violator] -= repayAmount;

        // Liquidator receives collateral + bonus from reserves
        uint256 collateralYield = repayAmount * (BASIS_POINTS + LIQUIDATION_BONUS) / BASIS_POINTS;

        // Yield comes from reserves (where the donated eTokens went)
        uint256 fromReserves = collateralYield > eTokenBalance[violator]
            ? collateralYield - eTokenBalance[violator]
            : 0;
        uint256 fromViolator = collateralYield - fromReserves;

        if (fromViolator > 0) eTokenBalance[violator] -= fromViolator;
        if (fromReserves > 0) {
            require(reserveBalance >= fromReserves, "insufficient reserves");
            reserveBalance -= fromReserves;
        }

        // Convert eTokens to underlying for liquidator
        underlying.transfer(msg.sender, collateralYield);

        emit Liquidation(msg.sender, violator, repayAmount, collateralYield);
    }

    /// @notice Check if an account is healthy (collateral >= debt * factor)
    function isHealthy(address user) public view returns (bool) {
        if (dTokenBalance[user] == 0) return true;
        uint256 collateralValue = eTokenBalance[user] * COLLATERAL_FACTOR / BASIS_POINTS;
        return collateralValue >= dTokenBalance[user];
    }

    /// @notice Repay debt
    function repay(uint256 amount) external {
        require(dTokenBalance[msg.sender] >= amount, "repay exceeds debt");
        underlying.transferFrom(msg.sender, address(this), amount);
        dTokenBalance[msg.sender] -= amount;
    }

    /// @notice Withdraw collateral
    function withdraw(uint256 amount) external {
        require(eTokenBalance[msg.sender] >= amount, "insufficient eTokens");
        eTokenBalance[msg.sender] -= amount;
        underlying.transfer(msg.sender, amount);
        require(isHealthy(msg.sender), "unhealthy after withdraw");
    }
}

/// @dev Flash loan provider simulation
contract FlashLoanProvider {
    MockToken public token;

    constructor(address _token) {
        token = MockToken(_token);
    }

    function flashLoan(address borrower, uint256 amount, bytes calldata data) external {
        uint256 balBefore = token.balanceOf(address(this));
        token.transfer(borrower, amount);

        // Callback
        (bool success,) = borrower.call(data);
        require(success, "callback failed");

        // Verify repayment
        require(token.balanceOf(address(this)) >= balBefore, "flash loan not repaid");
    }
}
